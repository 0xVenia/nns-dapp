use core::cell::RefCell;
use ic_cdk::export::Principal;

thread_local! {
    pub static TARBALL_WHITELIST: RefCell<TarballWhitelist> = RefCell::new(TarballWhitelist::default());
}

/// A whitelist of assset tarballs and operators permitted to upload the tarballs.
#[derive(candid::CandidType, candid::Deserialize, Clone, Debug, PartialEq, Eq, serde::Serialize, Default)]
pub struct TarballWhitelist {
    /// Whitelisted tarballs
    hashes: Vec<TarballHash>,
    /// Operators, other than controllers, permitted to upload.
    operators: Vec<Principal>,
}

/// A tarball hash with information to verify that the hash is correct.
#[derive(candid::CandidType, candid::Deserialize, Clone, Debug, PartialEq, Eq, serde::Serialize)]
pub struct TarballHash {
    /// The git commit that produced the tarball
    commit: String,
    /// The path of the file as generated by docker-build
    path: String,
    /// The sha256 hashes of the .tar.xz asset bundles in the release.
    ///
    /// TODO: Maybe these should be [u8;32].  Let's see how ergonomic that is, though.
    hash: String,
}

/// Determine whether a given caller may upload the given asset.
///
/// - A controller may upload an asset.
/// - TODO: A set of whitelisted users may upload a set of whitelisted assets.
pub fn may_upload(
    caller: &ic_cdk::export::Principal,
    is_controller: bool,
    hex_sha256: &str,
    tarball_whitelist: &TarballWhitelist,
) -> Result<(), String> {
    let mut reason = "Permission denied:  ".to_string();
    if is_controller {
        return Ok(());
    }
    reason = format!("{reason}  Caller '{}' is not a controller.", caller);
    if !tarball_whitelist.operators.contains(caller) {
        reason = format!("{reason}  Caller '{}' is not whitelisted to update assets.", caller);
        return Err(reason);
    }
    if !tarball_whitelist.hashes.iter().any(|hash| hash.hash == hex_sha256) {
        reason = format!(
            "{reason}  Tarball with hash '{}' is not whitelisted for upload.",
            hex_sha256
        );
        return Err(reason);
    }
    Ok(())
}

/// Creates a toy whitelist for testing purposes.
#[cfg(test)]
fn toy_whitelist() -> TarballWhitelist {
    TarballWhitelist {
        hashes: vec![TarballHash {
            commit: "caa36ce895eec16b6e59da586c3b5f6c55b9ac2a".to_string(),
            path: "out/assets-part1.tar.xz".to_string(),
            hash: "abba".to_string(),
        }],
        operators: vec![
            Principal::from_text("lanns-ouquq-hckhb-fgytd-vtn4m-rd5q4-hl3ct-vkwtm-ebcjo-xubks-kae")
                .expect("Invalid principal in test setup"),
        ],
    }
}
/// Checks that a given text contains a given substring.
///
/// # Panics
/// - If the text coes not contain the expected substring.
#[cfg(test)]
fn assert_contains(text: &str, expected: &str, description: &str) {
    if !(text.contains(expected)) {
        panic!("{} '{}' should contain '{}'", description, text, expected)
    }
}

#[test]
fn controller_should_be_permitted_to_upload() {
    let caller = Principal::from_text("qsgjb-riaaa-aaaaa-aaaga-cai").unwrap();
    let is_controller = true;
    let hash = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
    let whitelist = toy_whitelist();
    assert!(
        may_upload(&caller, is_controller, &hash, &whitelist).is_ok(),
        "Controller should be allowed to upload"
    );
}
#[test]
fn unauthorized_principal_should_not_be_able_to_upload_a_non_whitelisted_asset() {
    let whitelist = toy_whitelist();
    let caller = Principal::from_text("qsgjb-riaaa-aaaaa-aaaga-cai").unwrap();
    let is_controller = false;
    let hash = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
    let response =
        may_upload(&caller, is_controller, &hash, &whitelist).expect_err("Permission should have been denied.");
    assert_contains(
        &response,
        &format!("Caller '{caller}' is not a controller."),
        "The rejection message",
    );
    assert_contains(
        &response,
        &format!("Caller '{caller}' is not whitelisted to update assets."),
        "The rejection message",
    );
}

#[test]
fn operator_should_not_be_able_to_upload_a_non_whitelisted_asset() {
    let whitelist = toy_whitelist();
    let caller = whitelist.operators[0];
    let is_controller = false;
    let hash = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef";
    let response =
        may_upload(&caller, is_controller, &hash, &whitelist).expect_err("Permission should have been denied.");
    assert_contains(
        &response,
        &format!("Tarball with hash '{hash}' is not whitelisted for upload."),
        "The rejection message",
    );
}

#[test]
fn unauthorized_principal_should_not_be_able_to_upload_a_whitelisted_asset() {
    let whitelist = toy_whitelist();
    let caller = Principal::from_text("qsgjb-riaaa-aaaaa-aaaga-cai").unwrap();
    let is_controller = false;
    let hash = &whitelist.hashes[0].hash;
    let response =
        may_upload(&caller, is_controller, &hash, &whitelist).expect_err("Permission should have been denied.");
    assert_contains(
        &response,
        &format!("Caller '{caller}' is not whitelisted to update assets."),
        "The rejection message",
    );
}
